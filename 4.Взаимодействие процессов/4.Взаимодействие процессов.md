# Введение

IPC (межпроцессное взаимодействие) - ключевая часть любой ОС.
Тема неисчерпаемая, далее только некоторые основы.

IPC может быть локальным или сетевым.

Основными видами локального IPC в линукс являются 
- именованные и неименованные каналы
- разделяемая память

# Виды межпроцессного взаимодействия в Linux

- файлы
  - тривиальный вариант
  - с учетом буферизации записи в файловые дескрипторы, нужно заботиться о синхронизации доступа
- сигналы
  - некоторая аналогия прерываний, только на уровне ОС
- каналы (pipes)
  - именованные
    - имеют имя в общем дереве файлового пространства имен ОС
  - неименованные
    - нет имени в ОС (например | создает неименованный канал (ps aux|grep ...) между ps и grep)
- очереди сообщений (mqopen, mq_send, ...)
- разделяемая память (shared memory)
  - обеспечивается максимальная скорость взаимодействия
  - выделяется регион адресов, кот. отображается на адресные пространства нескольких приложений
- сокеты
  - абстракция всех сетевых протоколов
- posix-семафоры
- rpc (удаленный вызов процедур)
- IPC (System V)
  - исторический интерфейс, доступен, но практически не используется


# Каналы

Первый из появившихся механизмов IPC.

Создание канала:
- в ядре ОС создается буфер, через который будет проходит поток байт
- приложение получает два файлвых дескриптора (указаля на этот буфер) 
  - для чтения
  - для записи

- приложение порождает потомка, которые также сохраняют данные дескрипторы
  - в родителе можно закрыть дескриптор для чтения
  - в потомке можно закрыть дескриптор для записи
  - получился односторонний канал

**Канал**

В линукс `man 2 pipe`:

    #include <unistd.h>

    struct fd_pair {
        long fd[2];
    };
    struct fd_pair pipe();

    /* На остальных архитектурах */
    int pipe(int pipefd[2]);

    #define _GNU_SOURCE
    #include <fcntl.h>
    #include <unistd.h>

    int pipe2(int pipefd[2], int flags);

pipe()  создаёт  однонаправленный  канал  данных,  который можно использовать для взаимодействия между процессами. Массив pipefd используется для возврата двух файловых дескрипторов, указывающих на концы  канала.  pipefd[0]  указывает  на  конец канала  для  чтения. pipe2() чисто линукс функция - тоже самое, но можно добавить флаги и настроить буферизацию.

Там же есть пример.

**Неименованный канал** создается функцией `popen()`

    #include <stdio.h>

    FILE *popen(const char *command, const char *type);

    int pclose(FILE *stream);

Функция  popen()  открывает  процесс  следующим  образом:  создаёт  канал, выполняет fork и вызывает командную оболочку. Так как канал задается однонаправленным, в аргументе type может быть задан один режим: либо чтение либо запись.

Аргумент command представляет собой указатель на строку с null в конце, которая содержит командную строку оболочки. Эта команда  передаётся  в  /bin/sh  с  помощью флага -c; все подстановки в ней выполняются оболочкой.

Потоки вывода popen() по умолчанию блокируемые и буферизированные.

**Именованный канал** 

Создается функцией `mkfifo()`

Функция  mkfifo()  создаёт  специальный  файл  FIFO  с  именем  pathname и правами доступа mode. Как обычно, в правах учитывается значение umask процесса: права на создаваемый файл вычисляются как (mode & ~umask).

Специальный файл FIFO подобен каналу, за исключением того, что он создаётся другим способом.  Вызов  mkfifo()  вместо  безымянного  канала  взаимодействия  создаёт специальный файл FIFO, расположенный в файловой системе.

После  создания  специального  файла   FIFO,  любой  процесс  может открывать его для чтения или записи, как если бы он открывал обычный файл. Однако прежде чем вы       сможете что-либо сделать, его необходимо открыть с обоих концов, притом одновременно. Открытие FIFO для чтения обычно блокируется, пока какой-нибудь другой процесс не откроет его для записи, и наоборот. Описание работы со специальными файлами FIFO в неблокирующем режиме смотрите в fifo(7).


# Сигналы

Похожи на прерывания, которые заставляют процессор остановить выполнение программы, сохранить регистры, запустить обработчик прерывания, потом вернуть все как было. Тут похожая история, только не процессор, а ОС.

Обработчики сигналов линукс добавляются в приложение на этапе линковки из `libc`. Например обработка нажатия Ctrl+C.

Сигналов много и все они имеют номера, которые в <signal.h> (а точнее в <bits/signum-generic.h>) сопоставлены некоторым именам. Не путать с сигналами boost и других библиотек, это совсем другие сигналы.

Также как и с прерываниями обработчки сигналов могут быть перегружены (переопределены в приложении). Правда перегружены могут быть не все сигналы, часть из них могут использоваться только встроенными в ОС обработчиками (вроде сигнала безусловного завершения процесса SIGKILL (код 9))

Некоторые основные сигналы:

    Name        Code    Comment
    SIGINT      2       Прерывание с клавиатуры
    SIGABRT     6       abort(2)
    SIGTERM     15      "Просьба, не могли бы вы завершиться" (по-умолчанию для kill)
    SIGKILL     9       Безусловный сигнал завершения
    SIGCHILD    18      Дочерний процесс был завершен или остановлен

Сигналы - один из основных инструментов управления демонами (по сигналам приостановиться, перечитать конфиг и т.п.).

**Отравка сигналов** - системная функция `kill()` (так сложилось исторически)
    
    #include <sys/types.h>
    #include <signal.h>

    int kill(pid_t pid, int sig);

- Системный вызов kill() может быть использован для посылки какого-либо сигнала какому-либо процессу или группе процессов.

**Установка обработчка сигнала** - функция `signal()` `sigaction()`

    #include <signal.h>

    int sigaction(int signum, const struct sigaction *act,
                    struct sigaction *oldact);

- Работа вызова signal() различается в различных версиях UNIX, и такая же ситуация исторически сложилась и в различных версиях Linux. **Не используйте его**: используйте вместо него sigaction(2)
- sigaction, rt_sigaction - получает и изменяет обработчик сигнала
- Системный вызов sigaction() используется для изменения выполняемого процессом действия при получении определённого сигнала (список сигналов смотрите в signal(7)

Вывести список сигналов можно так (суффиксы)

    kill -l   
    HUP INT QUIT ILL TRAP IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS


# Разделяемая память

Каждый процесс "считает", что он использует системные ресурсы монопольно.

    Оборудование (в т.ч. физическая память)
    |
    Операционная система
    |
    Пользовательское пространство

Из физической памяти делается ОС формирует виртуальное адресное пространство с адресами от `0x0000..0` до `0xFFFF..F`:

Виртуальное (логическое) адресное пространство каждого процесса в линукс (примерная схема):

    Address         Что расположено
    __________________________________________________________________
    0xFFFF..F       Ядро ОС (1 GB)
    ...

    __________________________________________________________________
                        (случайный отступ, от атак на стек)
    __________________________________________________________________
    ...             Стек
    RLIMIT_STACK
        (e.g. 8MB)
                    __________________________________________________
                    (стек "растет вниз")
    __________________________________________________________________
                        (случайный отступ, от атак на mmap)
    __________________________________________________________________
    ...             Shared memory segment
                    (memory mapping segment)
                        включая IPC и маппинг динамических
                        библиотек (/lib/libc.so)
    __________________________________________________________________
                    (разделяемая память "растет вниз")

                    (куча "растет вверх")
    __________________________________________________________________
    ...             Куча (heap)                     Память процесса   

                    _____________________________
                        (случайный отступ, от атак на кучу)
                    _____________________________
                    Сегмент неинициализированных 
                    данных (.bss)
                        static char * uName;
                    _____________________________
                    Сегмент данных (.data)
                        static char * name = "name"
                    _____________________________
                    Сегмент кода (.text)
    ...                 /bin/executable
    __________________________________________________________________
    ...
    0x0000..0           (м.б. еще некая хрень)
    __________________________________________________________________

`man shm_overview`
Объекты  общей  памяти  POSIX  являются  устойчивыми  на  уровне  ядра. Объект будет существовать до самого отключения системы или до тех пор, пока все процессы не разорвут связь с объектом, после чего он может быть удален с помощью shm_unlink(3).

В  Linux  объекты  общей памяти создаются в виртуальной файловой системе (tmpfs(5)), которая обычно монтируется в каталог /dev/shm. Начиная с ядра версии 2.6.19, в Linux поддерживается использование списков контроля доступа (ACL) для управления доступа к объектам в виртуальной файловой системе.

У ОС есть **механизм виртуальной памяти**, который позволяет отображать приведенную выше схему памяти частично на физическую память, частично на HDD. В части разделяемой памяти это означает:
- один процесс в своем адресном пространстве в разделяемой памяти аллоцирует сегмент, получает его диапазон логических адресов
- другой процесс в свое адресном пространстве в разделяемой памяти аллоцирует сегмент, получает его диапазон логических адресов
- механимз виртуальной памяти ОС обеспечивает, что оба эти сегмента будут соответствовать одном диапазону адресов физической памяти.

Основные системные вызовы:
- `shmget()` получение/создание региона разделяемой памяти
- `shmat()` подключение к сущестсующему региону
- `shmdt()` отключение от региона памяти
- `shmctl()` управление параметрами региона памяти

    int shmget(key_t key, size_t size, int shmflg);

- возвращает  идентификатор  общего  сегмента  памяти  System V,  соответствующего  значению  аргумента  key.  Его  можно использовать для получения идентификатора ранее созданного общего сегмента памяти (когда shmflg равно нулю и key не содержит значения IPC_PRIVATE, которое говорит, что этот регион не для IPC, а чисто для самого приложения) или для создания нового.
- размер size округляется вверх до целого числа страниц

**Отладка**

Регионы разделяемой памяти живут дольше процессов. Для просмотра созданных регионов разделяемой памяти используется `ipcs`.


# Мультиплексирование ввода-вывода

Механизм, позволяющий приложению наблюдать за нескольких файловыми дескрипторами, не блокируясь на них.

Например,  пусть есть клиент-серверный чат, где клиент и сервер связаны двумя однонаправленными каналами.
- чтение из канала в котором нет данных (у которого статус "не готов") вешает (блокирует) приложение до тех пор, пока в канале не появятся данные для чтения
- такое поведение не позволяет асинхронно читать-писать в несколько каналов

**решение 1**: создать многопоточную программу, в каждом потоке/процессе будет свой файловый дескриптор (один поток - читатель, другой - писатель), и уже между ними как-то организовать взаимодействие, периодически они будут синхронизироваться. Вот эта пара будет например обеспечивать функционал клиент. Это вроде как не очень эффективно.

**решение 2**: хотелось бы как-то наблюдать за файловыми дескрипторами и осуществлять чтение-запись в них, только когда они готовы к этому.

Чтобы читать и писать одновременно в двух именованных каналах в однопоточном приложении воспользуемся функцией `select()` с набором макросов

    client -(канал cl2ser)-> server
          ^                |
          |_(канал ser2cl)_|       

Метфора тут такая: предположим у нас есть несколько открытых файлов, в т.ч. с файловыми дескрипторами 0, 1, 2 (stdin, stdout, stderr) 2, 3, 5 (f1, f2, f3).

Создадим список наблюдения: в виде контейнера битовых флагов. В линуксе есть для этого тип `fd_set`.
- устанавливаем в 1 те биты, которые соответствуют дескрипторами, за которыми мы наблюдаем

    fd_set watch_list;

- в <sys/select.h> определены макросы для работы с `fd_set`

    FD_ZERO(&watch_list);       // обнулить все
    FD_SET(f1, &watch_list);    // наблюдать за f1
    FD_CLR(f1, &watch_list);    // исключить f1 из списка наблюдения

- там же есть функция `select()`

    int select(f3 + 1, fd_set_read, fd_set_write, fd_set_except, time_wait)
    // количество дескрипторов, списки дескрипторов, время ожидания

- макрос 
    
    FD_ISSET(f1, &watch_list); проверить установлен ли флаг для f1


Из примера:

    ➜  select gcc -g select.cpp -o select              
    ➜  select ./select                   
    Descriptors: 3 4                                ➜  select echo "hello" > f1.fifo
    FD 3 is ready to read
    Get 6 bytes from 3 : hello

    FD 4 is ready to read                           ➜  select echo "hello" > f2.fifo
    Get 6 bytes from 4 : hello

    