# Введение

Тема необъятная, далее только некоторые основные моменты относительно сетевых интерфейсов:
- TCP
- UDP
- немного про сетевую отладку

# Принципы организации IP сетей

## Стек TCP/IP

Классификаций стека сетей TCP/IP много и разных. Основные из них:
- модель OSI
- RFC 1122

Уровни **RFC 1122** (который и называется "стек TCP/IP"):

4. Прикладной уровень (приложения)
   - протоколы http, ftp, telnet ....
   - это уровни 6-7 OSI
3. Транспортный уровень
   - протокол TCP
   - протокол UDP
   - это уровни 4-5 OSI 
2. Сетевой уровень (Internet layer)
   - протокол IP : структура пакетов + 
     - протоколы маршрутизаторов ICMP, IGMP
     - протоколы трансляции адресов ARP (ip->mac), RARP (mac->ip)
   - это уровень 3 OSI
1. MAC\*-уровень (link layer)
    - Ethernet, IEE 802.x, ISDN, ATM, FDDI
    - это уровни 1-2 OSI (физический и канальный)

\*) MAC - media access control

## 7 уровней OSI 

Вообще описывает не стек TCP/IP, а произвольные сети и виды сетевого взаимодействия. Модель OSI является референсной и немного синтетической, на практике распространенные протоколы сетевого взаимодействия не всегда четко вписываются в уровни этой модель.

Уровни **OSI**:
1. Физический уровень (передача сигнала через физическую среду)
   - среда (свет, радиоволна, кабель), уровни сигналов, тип модуляции, методы кодирования цифровых сигналов
2. Канальный уровень (data link) 
   - упаковка битов сигнала в кадры, контроль ошибок, контроль целостности
3. Сетевой уровнеь
   - архитектура сетей (группы узлов, маршрутизация данных между узлами)
4. Транспортный уровень 
   - пакетирование данных
   - организация потоков данных
5. Сеансовый уровень
   - правила установления сессий (сеансов связи между двумя узлами)
6. Уровень представления
   - преобразования протоколов и кодирование/декодирование, т.е. организация данных при их пересылке (например, сжатие, шифрование, и т.п. согласование формата передаваемых данных типа JPEG/TIFF, ASCII/EBCDIC, MPEG/QuickTime, mp3/wav)
7. Прикладной уровень
   - все конечные прикладные протоколы (взаимодействие приложения с сетью: http ftp и т.д.)

## Взаимодействие приложений на разных компьютерах

Клиент:
    - Приложение пишет в файл write()
    - ФС передает 
      - если файл локальный, то в локальную ОС - обращение к локальному ресурсу
      - если файл удаленный, то в клиентскую часть ОС (отвечает за клиенские подключения) - создается сетевое соединение:
        - коммуникационные средства - получают запросы
          - передающая среда - передает запросы по сети

Сервер:
        - передающая среда принимает запросы
      - коммуникационные средства - получают и транслируют запросы 
    - серверная часть ОС - обращается к локальной части ОС за доступом к локальным ресурсам

Мутная схема в общем. И в этой схеме имелось в виду, что 
- передающая среда и коммуникационные средства - это link layer стека TCP/IP
- гдето между ними транспортный (TCP) и сетевой уровень (UDP)
- клиентская и серверная часть ОС - это прикладной уровень стека TCP/IP (в данном примере с файлом - это ФС)

(так еще мутнее)

## Сокеты, семейства адресов

Такая разбивка стека протоколов TCP/IP направлена на то, чтоб замена протокола на более одном уровне никак не влияла на работу протоколов на других уровнях.
- меняем WiFi на Ethernet на первом уровне - все также работает, ничего на других уровнях менять не надо
- TCP на UDP на транспортном уровне - аналогично
- http на ftp на прикладном - аналогично

**Семейства адресов**
1. MAC
2. IP, IPX, IPv6
3. Пара IP:порт
4. доменное имя, е-мейл, ICQ ID, путь к файлу

Существуют средства трансляции адресов между всеми уровнями в обоиз направлениях.

Программно-аппартный уровень
1. Сетевые адаптеры
2. Драйверы сетевых адаптеров + драйверы сетевых протоколов
3 - 4. Системный интерфейс ОС (построен на прерываниях)
- системный интерфейс для сетевых взаимодействий - это интерфейс сокетов

**Сокет** абстрагирует
- сетевой адрес (за сокетом скрыты конкретное семейство сетевых адресов и организация сети)
- транспорт 
- базовые операции ввода/вывода 
  - открытие/закрытие взаимодействия (соеднинения) open/close
  - запись/получение write/send
  - чтение/отправка read/recieve

Сокеты отличаются для разных семейств адресов
Для протокола TCP/IP сокет связан с парой IP:порт

## Адресация в IP сетях

Основы протокола IP закладывались в 1970-x.

IPv4

- адрес занимает 4 байта
- для группировки устройств в сети используется маска подсети
  - битовая маска по размеру адреса, где 
    - 1 в неизменяемых битах адреса (соответствуют адресу подсети), 
    - 0 в изменяемых (соответствуют адресам узлов сети)
    - пишут 
      - либо полностью 255.255.255.0
      - либо количество битов адреса подсети 192.168.13.5/24

Между узлами в одной подсети возможно прямое соединение через хаб / свитч / концентратор (синонимы)
- он будет отбрасывать пакеты, у которых адрес подсети отличается
- хаб эмулирует шину

Чтобы соединяться с узлами из разных подсетей нужен маршрутизатор
- от будет пересылать пакеты между разными сетевыми интерфейсами в соотвествии с маской подсети
- одна подсеть, один сетевой интерфейс на устройстве
  - Маршрутизатор не может иметь менее двух сетевых интерфейсов

Маршрутизация — процесс (или алгоритмы) поиска маршрутов для трафика

Шлюз — это узел в локальной сети, обеспечивающий передачу трафика во внешнюю сеть (или из внешней сети)
  - Шлюз для узла 192.168.1.1/24 может иметь IP-адрес 192.168.1.2/16

# Понятие сокета

## Типы взаимодействия между узлами в сети

1. Unicast
- передача напрямую между узлами
2. Multicast
- вещание на несколько узлов (входящих в группу вещания)
3. Broadcast
- вещание на все подключенные узлы сети (входящие в конкретный широковещательный домен)

## Транспортные протоколы TCP и UDP

UDP может передавать только пакеты без гарантии доставки
- за один раз не более размера пакета (20-30 Кб)

TCP работает с потоками (похожи на отправку файла)
- драйвер разбивает поток на пакеты
- драйвер проверяет успешность доставки пакетов, досылает пропущенные

## Порядок взаимодействия по протоколу UDP

    Клиент                                                      Сервер
    __________________________________________________________________

    Команда создания сокета
    - получаем структуру данных сокета
    socket()                                                  socket()

    Команда привязки сокета к адресу/порту
    bind()                                                      bind()

    Команда отправки данных
    sendto()                                                recvfrom()

    Команда приема данных
    recvfrom()                                                sendto()

Команды - это системные вызовы линукс

До команды bind сокет не может ничего получать (но отправлять может, т.к. в этом случае ОС назначает для отправки порт автоматически (ephemeral port)). В библиотечных обертках данного системного вызова socket() часто системный вызов bind() делается неявно.

Чтобы убедиться, что данные получены нужно отдельно конструировать какито-то механизмы.

## Порядок взаимодействия по протоколу TCP

    Клиент                                                      Сервер
    __________________________________________________________________

    Команда создания сокета
    - получаем структуру данных сокета
    socket()                                                  socket()

    Команда привязки сокета к адресу/порту
    bind()                                                      bind()

    Команда готовности к приему пакетов
    - открытие порта/сокета на прослушивание
                                                              listen()

    Команда соединения
    - отравка по TCP сообщения о соединении к открытому сокету
    connect()                                                 
    
    Команда на подтверждение соединения
    - на сервере создается новый сокет для соединения с клиентским
                                                              accept()
                          Соединение установлено

    Команда отправки данных
    send()                                                      recv()

    Команда приема данных
    recv()                                                      send()


Итого у сервера 2 сокета:
- для приема соединений
- для соединения

# Разрешение имен

## gethostbyname или networking hello world

Пример `./hello.net/` на основе `man 3 gethostbyname`

## Функции для преобразования IP адресов

`man inet`
- различные вспомогательные функции для операций с адресами, в т.ч.
  - char *inet_ntoa(struct in_addr in); 
  - int inet_aton(const char *cp, struct in_addr *inp);

*) x86 кодирует биты в байте le, в сети адреса кодируются be

## Адреса IP

У сокетов обобщенное представление адресов, конкретная реализация которых определяется сетевым драйвером и протоколом, а сокет предоставляет единый интерфейс к ним. Тут есть такой путанный полиморфизм.

`man 7 ip`
- как например ip адреса представляются в сокетах

Адрес IP-сокета определяется как комбинация IP-адреса интерфейса и номера порта. В самом протоколе IP нет номеров портов, они  реализуются  протоколами более высокого уровня, например udp(7) и tcp(7). У неструктурированных (raw) сокетов номер протокола IP указывается в sin_port.

           struct sockaddr_in {
               sa_family_t    sin_family; /* семейство адресов: AF_INET */
               in_port_t      sin_port;   /* порт сокета в сетевом порядке байт */
               struct in_addr sin_addr;   /* Интернет-адрес */
           };

           /* Интернет-адрес */
           struct in_addr {
               uint32_t       s_addr;     /* адрес в сетевом порядке байт */
           };

Уот так уот

# Сокеты дейтаграм. Протокол UDP

## Инструменты отладки сетевых программ

`netstat`

- выводит интернет соединения, таблицы маршрутизации, статистику по интерфейсам, группы мультикаст-вещания и т.п.
- man говорит, что оно устарело и вместо нее используется 
  - `netstat` -> `netlist`
  - `netstat -r` -> `ip route`
  - `netstat -i` -> `ip -s link`
  - `netstat -g` -> `ip maddr`

- статистика `netstat -snu`

`netcat`/`nc`
- создание произвольные TCP и UDP серверов и клиентов. The nc (or netcat) utility is **used for just about anything under the sun** involving TCP, UDP, or UNIX-domain sockets.

## netcat пример с udp

`-l` сервер, без ключа - клиент

Server

  ➜  ~ nc 3000 -l
  test
  some text
  some text to send

Client

  ➜  ~ nc localhost 3000
  test
  some text

  ➜  ~ echo "some text to send" > data
  ➜  ~ nc localhost 3000 < data

## netcat пример с udp 2

`-u` переключает в режим UDP

Server

  ➜  ~ nc -u 3000 -l

Client 

  ➜  ~ netstat -anp | grep 3000
  (Not all processes could be identified, non-owned process info
  will not be shown, you would have to be root to see it all.)
  udp        0      0 0.0.0.0:3000                0.0.0.0:*                               8381/nc             

  ➜  ~ nc localhost 3000 -u
  test
  some text

  ➜  ~ echo "some text to send" > data
  ➜  ~ nc localhost 3000 -u < data

Причем на локальном хосте это соединение работает в обе стороны.

## Программирование клиента udp протокола

Датаграмма (англ. datagram, дейтаграмма) — блок информации, передаваемый протоколом через сеть связи без предварительного установления соединения и создания виртуального канала. 

Напишем "сервер" UDP

     1 #include <stdio.h>
     2 #include <sys/socket.h>
     3 #include <netinet/ip.h>
     4 #include <arpa/inet.h>
     5 #include <unistd.h>         // read
     6 
     7 
     8 struct sockaddr_in local;   // структура для адреса сети
     9 
    10 int main(int c, char ** v) {
    11 
    12     int s = socket(AF_INET, SOCK_DGRAM, 0);  // ipv4, дaтаграмма, вариант протокола
    13     printf("socket=%d\n", s);                // дескриптор (сокета)
    14 
    15     inet_aton("127.0.0.1", &local.sin_addr); // строку в адрес и в структуру
    16     local.sin_port = htons(1234);            // порядок байт (узловой -> сетевой)
    17     local.sin_family = AF_INET;
    18 
    19     // "открытие" порта
    20     int result = bind(s, (struct sockaddr*) &local, sizeof(local));
    21     printf("%d\n", result);
    22 
    23     char buf[BUFSIZ];
    24     read(s, buf, BUFSIZ);
    25     printf("%s\n", buf);                         
    26     printf("bye\n", buf);
    27 
    28     return 0;
    29 }

Сокет, как и файл, нужно закрывать (( Но, как и файлы, при завершении программы сокеты закрываются автоматически при выходе из области видимости.

Сервер:

  ➜  udp gcc -g udp.c -o udp
  ➜  udp ./udp  
  socket=3
  0
  hello

  bye

Клиент

  ~ nc localhost 1234 -u
  hello

# Сокеты ориентированные на соединения. Протокол TCP

## Программирование клиента и сервера tcp

Пример в `./tcp/tcp.c`

Сервер

  ➜  tcp gcc -g tcp.c -o tcp
  ➜  tcp ./tcp
  Usage: ./tcp [s(erver) | c(lient)]
  ➜  tcp ./tcp s

Клиент

  ➜  tcp netlist | grep 1234
  user1    12043 tcp      3 tcp       127.0.0.1:1234          0.0.0.0:0     LISTEN

Видим, это tcp сервер, он LISTEN (UDP всегда ESTAB)

  ➜  tcp ./tcp c
  ______________
  ➜  tcp ./tcp s             
  Hello

## Заключительный комментарий

Семейства системных вызовов `send()` `recv()` в основе имеют системные вызовы `read()` `write()`

Они отличаются 
- наличием флагов, включающих блокировку до окончания чтения, работу с ошибками, и некоторые другие режимы
- наличием ссылок на структуры, куда вызов занесет информацию об адресе, который передал клиент (в том виде, в котором он это сделает), очевидно, это также не обязательная информация.
- клиент передает данные через заполнение соответствующих структур и передачу ссылок на них в аргументах ответной функции `sento(socket, &dest_addr, &addrlen)`, сервер получит `recvfrom(socket, &src_addr, &addrlen)`

Поэтому в простых задачах они без последствий могут заменяться на `read()` `write()`. 
