# Жизненный цикл процесса в Linux

**Процесс** - контейнер некоторых ресурсов и владелец **потоков** исполнения (для линукс эта модель не полностью верна, но в целом норм). 

Ресурсы процесса:
- потоки исполнения
- регионы памяти
- открытые файлы и файловые дескрипторы
- сертификаты и credentials (в общем атрибуты безопасности)

Идентификатор процесса PID и его родителя PPID используются для управления деревом процессом
- в линукс все процессы организованы в виде дерева
- главный процесс systemd/init имеет PID 1, PPID 0 и является родителем прямым или косвенным все остальных процессов
- init появляется первым в ОС после ее старта

\*) Тут есть какая-то непонятная тонкость, потому что `pstree`  показывает главным systemd, а `ps -aux|grep init` показывает, что PID 1 это init... (Альт-линукс)


Запустим процесс в фоне:

    ➜  gdb ls
    a.out  bug.cpp  core  core.zst
    ➜  gdb less bug.cpp &
    [1] 132109
    [1]  + 132109 suspended (tty output)  less bug.cpp                                                                                    
    ➜  gdb pstree -p     
    systemd(1)─┬─ModemManager(2673)─┬─{ModemManager}(2690)
            │                    └─{ModemManager}(2693)
            ...
            ├─systemd(3395)─┬─(sd-pam)(3397)
            │               ├─at-spi-bus-laun(3462)─┬─dbus-daemon(3467)
            ...
            │               ├─gnome-terminal-(121938)─┬─zsh(121967)─┬─less(132109)
            │               │                         │             └─pstree(132117)


**Процессы-зомби**

- Родительский процесс порождает дочерний процесс
- Когда дочерний процесс завершается, он возвращает код возврата (int main() { ...; return 0;})
- Пока родительский процесс не запросит (?) код возврата дочернего процесса, структура в ядре, связанная с завершенным дочерним процессом, и хранящая атрибуты дочернего процесса, не будет удаляться (**процесс-зомби**)
- Если родительский процесс будет завершен до завершения дочерних процессов, то их родителями назначаются родители родителя

Само по себе состояние зомби для процесса абсолютно нормальное и штатное. Это просто часть механизма получения кода возврата от дочерних процессов, каждый завершаемый процесс какую-то долю времени формально находится в таком состоянии. Главное, чтобы такие процессы не накапливались, занимая ресурсы.

# Создание процессов fork/exec

Есть два механизма создания нового процесса:
- fork/exec
- clone

## Основная идея порождения процессов с fork/exec

Процесс создания процесса:
1. fork - точная копия текущего процесса 
   - в новую область памяти копируется своя память
2. exec - замена образа текущего процесса образом потомком
   - в новую область памяти копируется содержимое другого бинарника

## Атрибуты, наследуемые процессом при использовании fork

Вызов  fork()  создаёт  новый  процесс  посредством  копирования вызывающего процесса. Новый процесс считается дочерним процессом. Вызывающий процесс считается родительским процессом.
Дочерний и родительский процессы находятся в отдельных пространствах памяти. Сразу после fork() эти пространства имеют одинаковое содержимое. Запись в  память, отображение файлов (mmap(2)) и снятие отображения (munmap(2)), выполненных в одном процессе, ничего не изменяет в другом.

дочерний процесс получает
- PID PPID
дочерний процесс НЕ получает
- блокировки памяти
- список сигналов, ожидающих обработки этим процессом (изначально список пуст)
- таймеры
- cчётчики использования ресурсов

Также стоит учитывать следующее:

       *  Процесс  потомка  создаётся  с  одиночной  нитью — той, которая вызвала fork(). Всё виртуальное адресное пространство родителя копируется в потомок, включая
          состояние мьютексов, условных переменных и других объектов pthreads; в случае проблем с этим может помочь pthread_atfork(3).

ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
       При  успешном  завершении  родителю  возвращается  PID  процесса-потомка, а процессу-потомку возвращается 0. При ошибке родительскому процессу возвращается -1, процесс-потомок не создаётся, а значение errno устанавливается в соответствующее значение.

**По этому значению в коде и определяется, выполняется ли код потомка или код родителя в данный момент.**

Ну и далее `man fork`

## Семейство функций exec

Это не одна функция, а целое семейство с различными суффиксами (`man 3 exec` библиотечные функции):
- execl, execlp, execle, execv, execvp, execvpe - запуск файла на исполнение

Семейство функций exec() заменяет текущий образ процесса новым.
- если запустить например в main() без fork(), то просто будет запущен новый бинарник но с ресурсами, уже выделенными текущей программе main().

Чаще всего нам нужно execve() `man 2 execve` (системный вызов)

Вызов  execve  выполняет  программу,  задаваемую  pathname.  При  этом  программа,  выполняющаяся  вызвавшим  процессом,  замещается  новой  программой, заново инициализируется стек, куча и сегменты данных (инициализированные и не инициализированные).

\*) очевидно, процессы можно создавать как из бинарных исполняемых файлов, так и из интерпретируемых файлов с указанием бинарника интерпретатора.

## Общая схема создания процесса при помощи fork/exec

Итак, общая схема:

    //                                  /usr/bin/parent                     /usr/bin/child

    pid_t pid = fork();                 // parent               ->          parent
                                        // pid = X              ->          pid = 0 (переменная, но не PID процесса)
                                        //                                  child = parent'
    if (pid == 0){
        // это потомок
        exec("/usr/bin/child", ...);    //                                  child = /usr/bin/child, тут идет 
                                        //                                  работа потомка, код штатного возврата
        // обработка ошибок запуска
        exit(0);                        //                                  код нештатного возврата из потомка
    } else {
                                        // это родитель, работа родителя
        waitpid(pid);
    }

Процессы порожденные при помощи fork имеют доступ к памяти родителя до вызова exec, но только доступ на чтение, к неизменённым участкам(сегментам) памяти. 

Википедия:

Т.е. если не упрощать, то полной копии при fork() не происходит, используется Механизм копирования при записи (Copy-On-Write, COW). При работе UNIX-функции fork() вместо реального копирования, под которое надо выделять память, ядро меняет дескрипторы страниц памяти материнского процесса, запрещая какую-либо запись в страницы данных (страницы программного кода и так запрещены для записи; хотя здесь имеются свои тонкости — но на дальнейшие рассуждения они не влияют). Затем создаётся дочерний процесс, которому копируются дескрипторы страниц памяти материнского процесса. При этом ядро помечает эти страницы как совместно используемые.

Попытка записи в отображённые страницы (неважно, со стороны материнского или дочернего процесса) вызывает исключение (exception), которое передаёт управление в ядро. Ядро видит, что это обращение было законным, и создаёт копию изменяемой страницы. Таким образом удаётся снизить количество потребляемой программами физической памяти. Механизм COW достаточно сложен в реализации, особенно в многоядерных системах, а ошибки в нём могут приводить к уязвимостям, например, Уязвимость Dirty COW (Linux, 2007-октябрь 2016)

Механизм получил большое распространение при создании новейших файловых систем, таких как ZFS и Btrfs. Благодаря ему создание снимков в данных системах происходит практически мгновенно, не занимая при этом больших ресурсов носителя информации.

## Семейство функций wait

`man 2 wait`

wait, waitpid, waitid - ожидает смену состояния процесса. 

Сменой состояния считается: 
- прекращение работы потомка, 
- останов потомка по сигналу, 
- продолжение работы потомка  по  сигналу.  

Ожидание  прекращения работы потомка позволяет системе освободить ресурсы, использовавшиеся потомком; если ожидание не выполняется, то прекративший работу потомок остаётся в системе в состоянии "зомби (zombie)"

Системные вызовы wait являются синхронными, т.е. блокирует процесс, который их вызвал до получения кода возврата от потомка (определяемого исключительно по PID). Можно устанавиливать разные критерии для PID потомка (любой потомок /конкретный потомок / потомок из той же группы процессов что и родитель), потому что потомков может быть несколько.

# Атрибуты создаваемого процесса. Системный вызов clone

clone() более гибкий вариант создания дочернего процесса, при вызове которого можно указать, какие ресурсы родительного процесса копировать, какие создать заново, а какие могут использоваться совместно.

Если потомки, например, будут использовать совместно с родителями память, то это будет аналог потоков (pthreads на основе системного вызова clone() и сделаны)

Различаются оберточная функция clone() из glibc и системный вызов функции ядра clone(). Отличия в `man 2 clone`.

**Контекст процесса**

Включает (но не только):

- открытые файлы
  - дескрипторы выдает ядро, оно хранит их состояние, вот эта структура и есть часть контекста
  - стандартный ввод/вывод это тоже файлы, поэтому процессы должны корректно работать с ним в параллель
- файловые системы (mount)
  - монтируются в общее пространство имен
  - линукс позволяет для каждого процесса иметь свое представление этого пространства имен
  - зачем? например, сервер держит несколько вебсайтов, каждый процесс вебсервера работает со своим подмножеством пространства имен и они не смогут повлиять друг на друга
- операции ввода/вывода
  - например, незавершенные операции, запущеннные родителем
    - результат асинхронно придет потомкам, которые появились после такого запроса
  - или, например, устройство направило родителю данные (поместило в некоторую очередь), а родитель был не активен, но потом запустил потомков
    - такие данные будут доступны и потомкам тоже (это к тому, что потомок должен уметь такое обрабатывать, или, по крайней мере, код должен быть таким, чтоб такие данные хоть кто-то обработал, родитель или потомок)
- сетевое окружение
  - у процесса может быть свое изолированное пространство ip адресов
- множество индентификаторов процессов
  - можно создавать различные пространства таких идентификатов
  - это лежит в основе контейнеров виртуализации
- память
- состояние регистров
- имя хоста

Гибко комбинируя доступность и вид этих ресурсов (контекст) можно решать совершенно разные в том числе по своей сути задачи (от изоляции/виртуализации до параллельной обработки), точнее конфигурировать среду для решения таких задач.

## Системный вызов clone

       /* Прототип обёрточной функции glibc */

       #define _GNU_SOURCE
       #include <sched.h>

       int clone(int (*fn)(void *), void *child_stack,
                 int flags, void *arg, ...
                 /* pid_t *ptid, void *newtls, pid_t *ctid */ );

       /* для прототипа неструктурированного системного вызова, смотрите ЗАМЕЧАНИЯ */

`int (*fn)(void*)` это указатель на некоторую (любую) функцию, которая принимает любые аргументы и возвращает `int`
- а например `int (*fn)(void)` - это аналогичный указатель на функцию, но без аргументов

В линукс процесс рассматривается как основная единица планирования (т.е. ими планировщик управлет), все остальное - это организация использвования ресурсов (совместно или нет).

Аргументы clone()

- указатель на функцию, которая будет вызвана в потомке
- указатель на стек, который будет использовать потомок
- набор флагов, которые будут использованы при создании потомка
  - задают общие ресурсы родителя и потомка
- остальные атрибуты можно установить нулями

## Флаги clone

Например
- CLONE_FS общая /
- CLONE_NEWCGROUP новая контрольная группа (контейнер) 
- ну и т.д. `man 2 clone`

## Пример вызова clone

    #define _GNU_SOURCE
    #include <sched.h>
    #include <stdio.h>
    #include <stdbool.h>
    #include <unistd.h>     // usleep

    #define STACK_SIZE 10000
    char child_stack[STACK_SIZE];


    int child(void * params) {
        int c = 0;
        while (true) {
            usleep(500000);
            printf("child turn %d\n", c++);
        }
    }


    int main(void) {
        int c = 0;
        int result = clone(child, child_stack + STACK_SIZE - 1, 0, 0);
        printf("clone result = %d\n", result);

        while (true) {
            usleep(500000);
            printf("parent turn %d\n", c++);
        }
        
    }

    ➜  clone echo $$
    142172
    ➜  clone ./clone    
    clone result = 142320
    parent turn 0
    child turn 0
    parent turn 1
    child turn 1
    ...

В другои окне:

    ➜  ~ pstree 142172
    zsh───clone───clone

Один процесс - родитель другого

## Наследование родительского PID

Добавим флаг:

    int result = clone(child, child_stack + STACK_SIZE - 1, CLONE_PARENT, 0);  

Получили:

    ➜  ~ pstree 142172
    zsh───2*[clone]

По такому принципу примерно и устроено управление потоками, когда родитель у всех один и плюс еще общая память.


# Процессы-демоны

## Наследование сессии

**Проблема**: при завершении процесса родителя завершаются все его потомки.

Это не то поведение, которое требуется, если это процесс типа сервера.

## Процессы-демоны

Перевод процесса в демоны:

1. fork()   : создание процесса
2. в этом процессе перейти в корневой каталог /
3. установить в этом процессе новый id сессии
   - setsid(2)
4. закрыть файлы стандартного I/O
   - close(stdin);
   - close(stdout);
   - close(stderr);

Т.к. все "ручки управления" у демона теперь отключены, взаимодействие с ним нужно организовывать отдельно (сокеты, сигналы)
 

